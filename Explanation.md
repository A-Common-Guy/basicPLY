This project implements a robust point cloud registration pipeline for merging noisy, non-aligned 3D scans from different perspectives. The solution features a **custom-built Iterative Closest Point (ICP)** algorithm with an optimized KD-Tree for nearest neighbor search, automatic mirroring detection for handling symmetric ambiguities, and a multi-resolution coarse-to-fine refinement strategy. The implementation achieves convergence in under 100 iterations across tested scenes.
The case study implement a standard point-to-point and point to plane ICP algorithm, without any exotic implementation. The reason for that stand in the provided scenes, whose misalignement dwells at around 30 degrees or less. Being ICP a local solving strategy, we find the problem on the far end of the capability of this algorithm. 
ICP works by finding the rigid transformation that minimize the cumulative distance between all the points of a cloud and their nearest neighbors in the target one (normal distance in the case of point to plane). Working iteratively, this technique returns an homogeneus transform matrix composed of a translation a rigid rotation. As the name implies, this strategy needs to execute multiple times to obtain an acceptable result. The number of iteration is limited for practical reasons. Currently the stop conditions are on the reduction rate of the loss function evaluation (<0.001).
To operate into a feasible range of time, a series of optimization are executed on the whole pipeline. I would love to underline that those kind of loads are usually taken care using a shaders but the limited amount of time and my limited hardware limited my choice to cpu operations (4 parallel process on my puny old i7 are the best it can handle, at least on the nearest neighbors).
The first phase include the creation of the NN couples. The brute force approach is the easiest to implement, but represents immediately a severe performance limitation. Even switching to ANN (Approximate NN) approaches (which aren't implemented here) wouldn't save the day. The classical solution is to construct a KDTree <include small explanation on kdtress and my specific implementation>. Already this simple metod assured a x10 speed up on the single 2M pointcloud. Another 30% improvement arrived by switching a recursion based kd builder to a stack based one to avoid Python recursion inefficiencies.
Once constructed the tree, I hit the real performance wall by trying to run the comparison on all the possible couple (on the poin to point at least). At this point I introduced a very simple voxelizer